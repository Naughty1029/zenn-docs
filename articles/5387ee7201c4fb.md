---
title: "『コンピュータシステムの理論と実装』から学ぶ『現代のコンピューターの基本的な仕組みと設計思想』"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["computerscience"]
published: true
---

私たちが普段、何気なく使っているパソコンやスマートフォン。これらが「どうやってあんなにいろいろなことをこなしているのか？」と考えたことはありますか？

今回は『コンピュータシステムの理論と実装』という書籍で学んだ「現代コンピューターの基本的な仕組みと設計思想」について、同書で登場する教育用の簡易型コンピューター「Hackコンピュータ」の例も交えながら、まとめておきたいと思います。

## プログラム内蔵方式について
現代コンピューターの多様性と柔軟性を理解する上で欠かせない概念が「プログラム内蔵方式」です。

プログラム内蔵方式（Stored Program Concept）は、1940年代にフォン・ノイマンらによって体系化された画期的なアイデアで、現代のコンピューター科学の基盤とも言える発明です。
この方式が登場する以前の初期のコンピューターでは、実行したいプログラムの処理手順（ロジック）がハードウェアに直接組み込まれていました。
そのため、異なる計算を行うには、物理的に配線を変更したり、機械の構造を変更する必要がありました。

プログラム内蔵方式の革新的な点は、ハードウェアとソフトウェアの役割を明確に分離したことにあります。
ハードウェアは複雑なプログラムロジックから解放され、「メモリから命令を読み取り、解釈し、実行する」という単純で汎用的な処理のみを担当するようになりました。
一方で、複雑な処理はすべて、データと同じようにメモリに保存されるプログラム（ソフトウェア）として実現されるようになったのです。

この分離により、プログラムがメモリ上で書き換え可能になり、同じハードウェアで異なるプログラムを実行でき、ハードウェアの物理的な変更なしに多様なタスクが実行可能になりました。
これこそが「ソフトウェア」という概念の誕生であり、一台のコンピューターでゲーム、文書作成、計算、音楽再生など、まったく異なるタスクを実行できる理由です。

現代の複雑なソフトウェアも、ハードウェアが理解できる基本的な命令の組み合わせとして構成されています。
ハードウェアは単純な命令処理に特化することで汎用性を獲得し、すべての複雑さはソフトウェアが担うという、この役割分担こそがコンピューターの柔軟性と多機能性を飛躍的に向上させ、今日の情報社会の基盤を築いたのです。

## 現代コンピューターの青写真：「ノイマン型アーキテクチャ」

さて、そんなプログラム内蔵方式を具体的に実現した代表的なコンピューターモデルが、「ノイマン型アーキテクチャ (von Neumann Architecture)」です。

これは、現在のほとんど全てのコンピュータープラットフォームの概念的な設計図となっています。

ノイマン型アーキテクチャは、主に以下の要素で構成されています

:::message
- **CPU**
コンピューターの心臓部であり、プログラムの命令を実行する責任を負います。CPU自体は、ALU（演算論理装置）、レジスタ、制御ユニットという3つの主要なハードウェア要素で構成されています。
- **メモリ**
プログラムの命令だけでなく、コンピューターが操作するデータも保存される場所です。
- **入力装置 (Input Device)**
キーボードなど、外部からデータを受け取るための装置です。
- **出力装置 (Output Device)**
スクリーンやプリンターなど、処理結果を外部に表示するための装置です。
:::

これらの要素が相互に作用し、CPUがメモリから命令やデータを一つずつ取り出して（フェッチ）、処理を進めていきます。    

なお、CPUの動作は「フェッチ（命令の取り出し）→デコード（解読）→エクセキュート（実行）→リピート（繰り返し）」というサイクルを繰り返すことで成り立っています。

例えば「A = B + C」という計算を実行する場合は以下のとおりです。
:::message
1. **フェッチ**
メモリから「ADD命令」を取得
2. **デコード**
この命令が「加算処理」であることを理解
3. **エクセキュート**
BとCの値を加算してAに格納
4. **リピート**
次の命令へ進む
:::

![](/images/5387ee7201c4fb/20250709212737.png)

## Hackコンピュータの内部構造について

ここからは、『コンピュータシステムの理論と実装』で登場する簡易型コンピューターである、Hackコンピュータの内部構造を説明します。
Hackコンピュータはノイマン型アーキテクチャで構成され、16ビットのとてもシンプルなマシンです。 

![](/images/5387ee7201c4fb/hack-computer01.png)
 
その主要な構成要素を見ていきましょう。

### 1. CPU (中央処理装置)

HackコンピュータのCPUは、ALU、レジスタ、制御ユニットを含み、Hack機械語の16ビット命令を実行します。

:::message
- **ALU (Arithmetic-Logic Unit)**
加算、論理積、比較など、コンピューターが実行する全ての低レベルな算術および論理演算を行います。
- **レジスタ (Registers)**
CPU内に設けられた高速な記憶領域で、中間結果などを一時的に保存し、パフォーマンスを向上させます。Hack CPUには主に3つのレジスタがあります
    - **Dレジスタ (Data Register)**
    データ値を保存するために使われます。
    - **Aレジスタ (Address Register)**
    データ値の保存、命令メモリ（ジャンプ命令の時にPCに渡される）のアドレス指定、データメモリ（RAM[A]）のアドレス指定という3つの異なる目的に利用されます。
    - **PC (Program Counter)**
    次にフェッチして実行すべき命令のアドレスを常に保持している特殊なレジスタです。通常は自動的にインクリメント（PC++）されますが、ジャンプ命令がある場合はAレジスタの値がPCにロードされ、命令の実行フローを変更します。
 - **制御ユニット (Control Unit)**
 命令をデコードし、ALUやレジスタ、メモリといった様々なハードウェアデバイスに対して、その命令を実行するために必要な信号を送る役割を担います。また、次に実行すべき命令を決定するのもこの部分の役割です。
:::

以下はNand2Tetrisプロジェクトで紹介されているCPU実装案です。参考までに。
![](/images/5387ee7201c4fb/hack-computer04.png)

### 2. メモリ

Hackコンピュータのメモリは、物理的には「アドレス指定可能なレジスタの並び」として構成されており、各レジスタが固有のアドレスと値を持ちます。  

Hackコンピュータは、命令とデータを別々の物理メモリユニットに保持する、いわゆる「ハーバードアーキテクチャ」の一種を採用しています。  
※命令はROMに保存。データはRAMに保存されています。

:::message
- **命令メモリ (Instruction Memory)について**
    - Hackコンピュータでは、プログラムの命令はROM (Read-Only Memory)と呼ばれる読み出し専用メモリに格納されます。一度書き込まれると、実行中にその内容を書き換えることはできません。
    - CPUは、この命令メモリからバイナリの機械命令をフェッチ（読み出し）、デコードし、実行します。
    - Nand2Tetrisのプロジェクトで用意されたソフトウェアシミュレータには、外部のテキストファイル(.hack)から命令メモリにプログラムをロードする機能が提供されます。
- **データメモリ (Data Memory)について**
    - これはRAM (Random Access Memory)デバイスで、データを読み書きできます。
    - Hackコンピュータのデータメモリは、通常のデータストレージとしてのRAM（16Kレジスタ）に加え、スクリーン（8Kレジスタ）とキーボード（1レジスタ）のメモリマップも含むという特徴があります。
:::

Hackのデータメモリ（Memory）は、以下の3つの装置を内部で統合した構造になっています

| 構成要素 | アドレス範囲 | 機能・役割 |
| ---------- | ---------------------------- | ------------------------------- |
| **RAM16K** | 0 ～ 16383（0x0000～0x3FFF） | 通常のデータ格納 |
| **スクリーン**  | 16384 ～ 24575（0x4000～0x5FFF） | 画面ピクセル表示用（Memory-Mapped Output）|
| **キーボード**  | 24576（0x6000） | 入力キー取得用（Memory-Mapped Input） |

![](/images/5387ee7201c4fb/hack-computer03.png)

### 3. 入出力 (I/O)

Hackコンピュータは、スクリーンとキーボードという2つの入出力デバイスとやり取りします。
これらのデバイスは、「メモリマップドI/O (Memory-Mapped I/O)」というスキームによって管理されています。

:::message
- **メモリマップドI/O**
I/OデバイスをCPUから見ると、あたかも通常のメモリセグメントであるかのように扱われます。各I/Oデバイスには、メモリ内に専用の領域が割り当てられ、これがそのデバイスの「メモリマップ」となります。

具体的な動作は以下のようになります
- 入力デバイス（キーボード）の場合、メモリマップはデバイスの物理的な状態を継続的に反映します。ユーザーがキーを押すと、そのキーを表すバイナリコードがキーボードのメモリマップに現れます。
- 出力デバイス（スクリーン）の場合、スクリーンは指定されたメモリマップの状態を継続的に反映します。メモリマップにビットを書き込むと、スクリーン上の対応するピクセルがオンまたはオフになります。
 
* これにより、コンピュータープログラムは、**I/Oデバイス専用のメモリ領域内のレジスタを操作するだけで**、そのデバイスにアクセスできるようになります。CPUの設計をI/Oデバイスの数や種類から独立させることができるという大きな利点があります。
:::

### まとめ：Hackコンピュータが示すコンピューターの原理
Hackコンピュータは、現代の汎用コンピューターの基本的な動作原理とハードウェア要素を理解する上で非常に優れたモデルだと感じました。
今回の記事ではHackコンピュータの概要の説明までしか書いていませんが、時間があれば、それぞれのモジュールについてもスポットを当てながら詳細な記事も書いてみたいと思います。

また、一般的なコンピューターは、Hackよりも多くのレジスタ、データ型、ALU、そして豊富な命令セットを持っていますが、これらは主に量の違いに過ぎません。
Hackは、**プログラム内蔵方式やノイマン型アーキテクチャ**といった質的な観点では、ほとんどのデジタルコンピューターと共通の概念になります。

このHackコンピュータを実際に構築するプロジェクトを通じて、コンピューターが低レベルのハードウェアとソフトウェアでどのように動作するのかについて、深い理解を得られるのではないでしょうか。

### リソース
* [Nand2Tetris Projects](https://www.nand2tetris.org/)
* [コンピュータシステムの理論と実装 第2版](https://www.oreilly.co.jp/books/9784814400874/)
