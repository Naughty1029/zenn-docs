---
title: "なぜDBのリバースエンジニアリングは完璧にできないのか"
emoji: "🔄"
type: "tech"
topics: ["database", "設計", "リバースエンジニアリング"]
published: true
---

## はじめに

データベースの既存テーブル構造を見ながら、

> 「このシステム、元はどんな設計だったんだろう？」

と考えたことはありませんか？

私自身、システム改修や引き継ぎの場面で、まずDBを眺めて「設計意図」を読み取ろうとすることがよくあります。  
そんなとき、ベテランエンジニアにこう言われたことがありました。

> 「DBのリバースエンジニアリングで、完璧な設計を復元するのは無理だよ」

最初はピンときませんでしたが、複数のシステムを触るうちに、その意味が少しずつ分かってきました。

この記事では、

- なぜDBのリバースエンジニアリングは完璧にできないのか
- それでもなぜ意味があるのか
- どう向き合うのが健全なのか

を、**料理の例え**と**具体的なDB設計の例**を使って解説します。

## DBリバースエンジニアリングとは

DBリバースエンジニアリングとは、  既存のデータベースの **物理構造（テーブル・カラム・リレーション）** から、元の **概念設計や論理設計を推測する行為** です。

通常の開発は、

```

要件定義 → 概念設計 → 論理設計 → 物理設計

```

という流れで進みます。

リバースエンジニアリングは、この流れを逆にたどり、

```

物理設計 → 論理設計？ → 概念設計？

````

を推測しようとします。

しかし、この逆向きの作業には、構造的な限界があります。  
それを理解するために、まずは料理の例で考えてみましょう。

## 完成したカレーから元のレシピは分かるか

完成したカレーライスがあるとします。  
それを食べたり、具材を観察したりして、元のレシピを完璧に復元できるでしょうか？

- じゃがいも
- にんじん
- 玉ねぎ
- 肉

といった 材料は分かるかもしれません。

しかし、次のことは分かりません。

- なぜこの組み合わせにしたのか
- どんな順番で調理したのか
- どこで妥協したのか
- 本当はどんな料理を目指していたのか

完成品から分かるのは「結果」であって、作り手の意図や判断の背景ではありません。

ここまで料理の例えで説明してきましたが、  この「完成品からは意図が分からない」という問題は、データベース設計でもそのまま当てはまります。

料理で言えば、

- 具材が分かる → テーブルやカラムが分かる
- 味は分かる → データの中身は見られる

しかし、

- なぜその設計になったのか
- どんな制約があったのか
- どこが理想で、どこが妥協だったのか

といった情報は、すでに削ぎ落とされています。

では、この問題がDB設計ではどのように現れるのでしょうか。

## 例：`status` カラムから設計意図は復元できるか？

あなたが新しいプロジェクトに参加し、次のようなテーブルを見つけたとします。

```sql
CREATE TABLE orders (
  id INT PRIMARY KEY,
  user_id INT,
  status VARCHAR(20),
  updated_at TIMESTAMP
);
````

一見すると、よくある「注文テーブル」に見えます。
しかし、この `status` カラムが**何を意味しているのか**は、テーブル構造からは分かりません。

考えられる可能性は複数あります。

* 注文処理の進捗管理

  * `CREATED` → `PAID` → `SHIPPED`
* 決済状態の管理

  * `UNPAID` → `PAID` → `REFUNDED`
* 業務フロー全体の状態

  * `DRAFT` → `CONFIRMED` → `CANCELLED`

さらに現実的なのは、**途中で意味が変わっているケース**です。

* 初期は「決済状態」だけを表していた
* 後から「配送状態」も流用された
* 過去データと現在データで意味が違う

このテーブル構造だけを見て、

* 正しい状態遷移は？
* どの状態で返金可能か？
* `CANCELLED` は決済前か後か？

といった **ビジネス上の重要な判断**を正確に行うことはできません。

この `status` カラムの例は、完成したカレーからレシピを推測する状況とよく似ています。

* `status` がある → 具材は分かる
* 値が入っている → 味はする

しかし、

* 状態遷移のルール
* 業務上の意味
* 設計者がどこで悩み、どこで妥協したか

は、どこにも書かれていません。

つまり私たちは、

> 「このカレー、たぶんこういう料理なんだろう」

と想像しているだけなのです。

## なぜDBリバースエンジニアリングが完璧にできないのか

### 1. 物理設計は「答え」ではなく「結果」だから

DBに残っているのは、

* テーブル
* カラム
* リレーション
* 制約

といった **最終的な結果**です。

しかしその裏には、

* なぜこの設計を選んだのか
* 他にどんな選択肢があったのか
* なぜそれを捨てたのか

という **判断の履歴** があります。

この判断理由は、物理設計には保存されません。

### 2. 実装・運用によって設計は歪む

多くのシステムでは、リリース後に次のような変更が加えられます。

* パフォーマンス改善のための非正規化
* 緊急対応としてのカラム追加
* 想定外の機能流用

```sql
CREATE TABLE orders (
  id INT PRIMARY KEY,
  user_id INT,
  status VARCHAR(20),
  user_name VARCHAR(100) -- パフォーマンス対策
);
```

後から見たエンジニアは、

> 「なぜ正規化されていないのか？」

と疑問を持つかもしれません。

しかし実際には、

* JOIN がボトルネックだった
* 画面表示速度を優先せざるを得なかった

という **現実的な判断** の結果であることがほとんどです。

### 3. 異なる設計意図が同じ構造に収束する

注文管理、契約管理、申請ワークフロー。
これらはすべて、

* 親テーブル
* 明細テーブル
* status カラム

という似た構造で実装できます。

**構造が似ている = 意味も同じ**
とは限りません。

これが、リバースエンジニアリングの限界です。

## まとめ：完成したカレーと、失われたレシピ

DBのリバースエンジニアリングが完璧にできない理由は、完成したカレーからレシピが分からないのと同じです。

DBは完成品であり、

* 何があるかは分かる
* どう動いているかは見える

しかし、

* なぜそう設計したのか
* どこが理想で、どこが妥協か

は、DBそのものには残りません。

### だから設計ドキュメントやADRが重要になる

設計ドキュメントやADRは、

* なぜその設計を選んだのか
* どんな選択肢があったのか
* どんな制約があったのか

という、**DBには残らない情報**を補完します。

DBが「完成した料理」なら、設計ドキュメントは「レシピ」です。

レシピが残っていれば、後から参加したエンジニアも、正しい前提で判断できます。

### リバースエンジニアリングの正しい位置づけ

DBリバースエンジニアリングは、

* 答えを復元するための手法ではなく
* **正しい質問を作るための手法**

です。

構造を読み、仮説を立て、人に聞く。
その先にしか、本当の設計理解はありません。

完成品だけを渡さない。
それが、未来のエンジニアへの一番の思いやりなのだと思います。