## 前提

- コンピュータシステムの理論と実装とは
    - Nand論理ゲートだけ与えられていて、そこから別の論理ゲートをつくっていき、それらをさらに組み合わせ、ALU / RAM、CPU、コンパイラ、OSを自作し、コンピュータ上でテトリスを動かすという学習プロジェクト
    - もともと、WEB上に[Nand to Tetris](https://www.nand2tetris.org/)という英語プロジェクトが無料で公開されており、本書はその日本語版のオライリー書籍
- Nand論理ゲートとは？
    - パソコン、携帯電話、ネットワークルータであれ、あらゆるデジタル機器はバイナリデータを保存し、処理するために、設計されたチップを内蔵している
    - そのようなチップを構成する要素はどれも同じで、論理ゲートと呼ばれる
    - Nand To TetrisではNandゲートのみが与えられていて、Nandからその他すべてのゲートを作っていき、それらのゲートを組み合わせてALUやRAMなどを実装していくことになる
- このプロジェクトの優れていると感じた点は、始めようと思えば、それぞれの章のどこからで始められるところ
    - モジュール設計に優れていて、学習者はそれぞれの章で登場するモジュールのHow（どのように実装されているか）を知らなくても、What（そのモジュールで何ができるのか）を確認すれば、その章の実装が進められるようになっている
    - 本書では、「抽象化と実装」という言葉で表しているが、これはシステムエンジニアリングにおける最も重要なルールとして、モジュールを構成要素として使用する場合、モジュールの抽象化のみを考え、その実装については完全に無視できるとして、この書籍全体を貫くコアテーマのように感じる

## メモリとは

- X=Y+17のように変数に計算結果を持たせ、後で使うまで、その値を保持させる必要がある
    - そのためにはメモリチップというものが必要になる
- しばしばエンジニアリングをしていると「メモリが枯渇して…」とか「メモリ容量どうする？」などの会話をすることがあるが、実のところメモリとはどのような仕組みで動いていて、どのようにデータの読み書きを行うのかを知っている人は多くないのではないだろうか？
- データを保持することを考えると、新たにコンピュータに与えなくてはいけない概念がある
    - 時間である
- NandゲートやAnd、Orゲートなどは入力信号を与えると即座に出力が得られるチップである。そのようなチップのことを組み合わせ回路という
- 一方で、現在の入力だけでなく、過去に処理した入出力にも依存する順序回路と呼ばれます。
    - 現時点で、どういう意味かはわからないと思うが、このあとRAMの実装を進めていくうちに意味がわかるようになるので悪しからず
- いったん、ここではRAMのようにデータを保持するには、過去と現在のような時間という概念と回路を密接に結びつけていくことが必要そうだというところまで理解していれば大丈夫
- では、つぎはなにを考えるべきだろうか？時間という概念が必要になるということは、時間の進み方をモデル化する必要がある。
    - コンピュータシステムにおける時間は、tickとtockと呼ぶバイナリ信号を生成するクロックを使ってモデル化する
    - tickの始まりとその次のtockの終わりの間の時間はサイクルと呼ばれ、このサイクルを使って、コンピュータのすべてのメモリチップの動作を制御することができるようになる
        
        ![スクリーンショット 2025-11-23 14.13.44.png](attachment:22af70c1-585b-4ab7-9a4a-a8fb634ea22d:スクリーンショット_2025-11-23_14.13.44.png)
        

## 時間について

- 時間について、もう少し細かく考えておく
- 通常、時間は一方向に進む矢印として比喩的に表される
    - 一般的には、時間の流れは連続的であり、2つの時間の間には別の時間が存在する。時間と時間の間の時間がどれだけあるかは…ちょっとわからないですね笑
- 一方で、この時間をコンピュータシステムで利用できるようにモデル化するときは、連続的ではない、サイクルと呼ばれる一定の長さの区分に分割する、離散的な表現方法を用いる
- この離散的な時間を導入することでコンピュータアーキテクチャ設計に重要な2点の利点が得られる
    - 通信や計算時間の遅れに伴うランダム性を打ち消す
    - システム全体で異なるチップの動作を同期させることができる
        - 具体的に、例えばNotゲートに1を入力すると、ゲートの出力が0になるまでにはわずかの時間がかかる
        - しかし、1サイクルの時間はその遅延よりも意図的に長くしてあるので、、サイクルの終わりに到達した時に、ゲートの出力は0に安定している
        - 各サイクルの最後に観測を行うことでNotゲートにxというバイナリ入力を与えると、Not(x)を瞬時に安定して利用することができるようになる
        - なお、上記の方式であるため、サイクルの長さを適切に設定することはハードの設計には重要なパラメータとなる
            - サイクルはシステムで起こりうる時間遅延に対応するだけの十分な長さであるべき
            - 一方で、サイクルが短ければ短いほどコンピュータははやくなる
            - 現在では、スイッチング技術の発展により、10億分の1秒というサイクルを作り出せるようになり、コンピュータ速度が向上している

## フリップフロップ回路について

- さて、時間のモデル化まで理解したら、ようやく順序回路に話題を移っていく
    - メモリチップは情報を保存するように設計されているが、きの記録いう行為を可能にする低水準ゲートはフリップフロップゲートと呼ばれる
    - NandtoTetrisのプロジェクトでは、Dフリップフロップというタイプが使用されていて、このゲートは予め学習者に与えられている
    - インターフェースは下記のようになっており、1ビットのデータ入力と1ビットのデータ出力を含んでいて、各サイクルの時間単位に前の時間単位の入力値を出力する
        - どんな実装？ということも気になるが、ここでは深く考えずにそのインターフェースのみを考えるようにする
        
        ![フリップフロップ回路のインターフェース](attachment:63b6c166-2f43-4d6b-a25b-54cea52e45c1:スクリーンショット_2025-11-23_14.47.48.png)
        
        フリップフロップ回路のインターフェース
        
- このあと、メモリチップ（レジスタ・RAM・カウンタ）を作っていくが、すべてはこのDFF回路をもとにして作られる
- それでは実際にDFF回路からレジスタ・RAM・カウンタを実装していこう

## 各チップの仕様

### DFF（データフリップフロップ）

- まずはDFF。
- 改めて、DFFとは、1ビットの情報を保持する基本回路であり、自kジャン軸に沿って動作する最小の順序回路である
- インターフェース
    
    ```jsx
    Inputs: in //現在の入力
    Outputs: out //1クロック前の入力値
    Funtionally:
    out(t)=in(t-1)
    ```
    
- なぜ上記の仕様で記憶になるのか？
    - 今の入力が次のクロックの出力になるからである
    - 例として以下はDFFのinとoutの入出力をまとめて表です
        
        
        | クロック時刻 | in | out |
        | --- | --- | --- |
        | T0 | 0 | 未定義 |
        | T1 | 1 | 0 |
        | T2 | 0 | 1 |
        | T3 | 1 | 0 |
    - 上記をみるとoutの値は、”過去”のinの値となっている。つまり、過去を記憶していると捉えることができる
- DFFだけでメモリは作れる？
    - 過去を記憶できてるなら、DFFをたくさん用意すればあっという間にメモリが完成しそうである
    - だが、いまのままでは記憶する能力はあるものの、指示なしに常に記憶を上書きしてしまう状態である
        - そのため、いつ記憶するかを制御できるようにするチップが必要となる
        - それがBitチップである

### Bitチップ

- 1ビットの記憶装置で、load = 1のときだけ新しい値を記憶するチップ
    - load = 1のときという制御を加えることで、DFFの値をいつ上書きするかを制御できるようにする
- インターフェース
    
    ```jsx
    Inputs: in,load //現在の入力
    Outputs: out //1クロック前の入力値
    Funtionally:
    if(load(t-1)) then out(t) = in(t-1)
    else out(t) = out(t-1)
    ```
    
    - load = 1 →次のクロックでinを記憶する
    - load = 0 → 何が入力されても無視して前のoutを保持する
- 実装
    
    ```jsx
    CHIP Bit {
        IN in, load;
        OUT out;
    
        PARTS:
        Mux(a=dffout , b=in , sel=load , out=muxOut );
        DFF(in=muxOut , out=dffout, out=out );
    }
    ```
    
    - 実際、Bitチップを実装するには上記のようなHDLを実装しました
    - 回路構成
        
        ![スクリーンショット 2025-11-23 16.40.29.png](attachment:c5e53b7b-3916-4a18-aaee-7fa0b527508f:スクリーンショット_2025-11-23_16.40.29.png)
        
    - load = 1のとき（新規値を記憶）
        - Muxが`in`を選択 → DFFに入力 → 次のクロックで`in`が出力される
    - load = 0のとき（値を保持）
        - Muxが`dffout`(前の値)を選択 → DFFに戻す → 同じ値がループし続ける
    - チップの流れ
        1. Mux: `load`で「新規入力(`in`)」か「前の値(`dffout`)」かを切り替える
        2. DFF: 選ばれた値を1クロック保持
        3. フィードバック: `dffout`が次のクロックでMuxの`a`に戻ることで値が保持される
    
    つまり、load=0のときDFFの出力が自分自身にループバックすることで「記憶の保持」を実現している
    
    - なお参考までにMUXチップのインターフェースは下記です
        
        ```jsx
        Inputs: a, b ,select
        Outputs: out
        Funtionally:
        if(sel === 0) then out = a, else out = b
        ```
        

### registerチップ

- 16ビットの値を記憶・保持するチップです。16個のBitチップを1つにまとめ、1本のload信号で一括制御できるようにしたチップです
- え？なんでBitチップをわざわざまとめる必要があるのでしょうか？
    - コンピュータでなにかしらの値を保持するには1ビットでは足りないことがほとんどです。数字、アドレス、命令など全てが通常16ビットの複数ビットで構成されています。
    - つまり、実用的なデータ(数値・アドレス・命令)を扱うには複数ビット必要で、それらを1つの単位として扱えるようにしたのがRegisterチップということになります
- 実装
    
    ```jsx
    CHIP Register {
        IN in[16], load;
        OUT out[16];
    
        PARTS:
        //// Replace this comment with your code.
        Bit(in=in[0] , load=load , out=out[0] );
        Bit(in=in[1] , load=load , out=out[1] );
        Bit(in=in[2] , load=load , out=out[2] );
        Bit(in=in[3] , load=load , out=out[3] );
        Bit(in=in[4] , load=load , out=out[4] );
        Bit(in=in[5] , load=load , out=out[5] );
        Bit(in=in[6] , load=load , out=out[6] );
        Bit(in=in[7] , load=load , out=out[7] );
        Bit(in=in[8] , load=load , out=out[8] );
        Bit(in=in[9] , load=load , out=out[9] );
        Bit(in=in[10] , load=load , out=out[10] );
        Bit(in=in[11] , load=load , out=out[11] );
        Bit(in=in[12] , load=load , out=out[12] );
        Bit(in=in[13] , load=load , out=out[13] );
        Bit(in=in[14] , load=load , out=out[14] );
        Bit(in=in[15] , load=load , out=out[15] );
    }
    ```
    
- ポイント
    - 上記、Bitチップが16個まとまっただけなので、一個前のBitチップの実装内容がわかっていればむずかしいことはないかと思います
    - 複数ビットを記憶する＝Bitチップを並列に扱うとことなんだと理解すれば大丈夫です
    - また、その際にloadを使うことで一括制御ができる点もポイントです
    - このRegisterチップを組み合わせていくことで、RAMチップになっていきます
- Registerチップがあればメモリは作れるか？
    - 複数ビットを扱える記憶の箱ができました。これでRAMチップも作れるでしょうか？
    - いえ、もうひとつ重要な考慮事項があります。それはどこに読み書きを行うかを制御しないといけません
    - このRegisterチップをたくさん組み合わせて記憶の箱をコンピュータの中に実装するのですが、どの箱にアクセスするかを制御できなければ、意味ないですよね
    - それがアドレッシングという技術であり、それを実現するのがRAMです。そして、NandtoTetrisにおいて、最小のRAMがRAM8チップです

### RAM8チップ

- 8個の16ビットRegisterをもち、「3ビットのアドレス」でどれを使うかを選べる記憶装置
- インターフェース
    
    ```jsx
    Inputs: in[16],load, address[3]
    Outputs: out[16] //1クロック前の入力値
    ```
    
- 回路の考え方
    - Register：8個
    - DMUX8way: load信号を8本に分配
    - MUX8way16 : 8個のRegisterから1つを読んで出力
    
    ```jsx
    CHIP RAM8 {
        IN in[16], load, address[3];
        OUT out[16];
    
        PARTS:
        // load信号を8本に分岐（addressに基づいて1本だけ1）
        DMux8Way(in=load, sel=address, 
                 a=load0, b=load1, c=load2, d=load3,
                 e=load4, f=load5, g=load6, h=load7);
    
        // 各Registerに分配されたload信号を与える
        Register(in=in, load=load0, out=out0);
        Register(in=in, load=load1, out=out1);
        Register(in=in, load=load2, out=out2);
        Register(in=in, load=load3, out=out3);
        Register(in=in, load=load4, out=out4);
        Register(in=in, load=load5, out=out5);
        Register(in=in, load=load6, out=out6);
        Register(in=in, load=load7, out=out7);
    
        // 出力の選択（アドレスに応じてどれか1つを選ぶ）
        Mux8Way16(
          a=out0, b=out1, c=out2, d=out3,
          e=out4, f=out5, g=out6, h=out7,
          sel=address, out=out);
    }
    ```
    
- ポイント
    - 記憶装置を複数持つ：Registerを8個並べる
    - どれに書き込む？：loadをDMUX8Wayで分配する
    - どれを読み込む：Mux8way16でaddressに応じて出力
    - アドレッシング基本：2の3乗→8個選択
- なお参考までにMUXチップのインターフェースは下記です
    
    ```jsx
    Inputs: a, b ,select
    Outputs: out
    Funtionally:
    if(sel === 0) then out = a, else out = b
    ```
    

# RAM8チップの仕組み

## 目的

8個の16ビットRegisterを持ち、3ビットのアドレスで「どのRegisterに書き込むか/読み出すか」を選択できるメモリ装置

## 回路全体図

```
                    address[3]
                      ↓   ↓
         ┌───────────────────────────┐
   load ─┤ DMux8Way                  │
         └┬──┬──┬──┬──┬──┬──┬──┬───┘
          │  │  │  │  │  │  │  │
       load0 load1... ...load7
          ↓  ↓              ↓
    ┌───Reg0─────┐    ┌───Reg7─────┐
in─┤→in  out→out0│... │→in  out→out7│
    └────────────┘    └────────────┘
          ↓                  ↓
         ┌────────────────────┐
         │   Mux8Way16        │
         │   sel=address      │
         └──────┬─────────────┘
                ↓
               out

```

## ステップバイステップ解説

### **Step 1: 書き込み制御（DMux8Way）**

```
load=1, address=011 (3) の場合

DMux8Wayが address を見て load信号を分配:
  load0 = 0
  load1 = 0
  load2 = 0
  load3 = 1  ← address=3 なのでここだけ1
  load4 = 0
  load5 = 0
  load6 = 0
  load7 = 0

```

**役割**: 「どのRegisterに書き込むか」を1つだけ選択

### **Step 2: データ書き込み（Register × 8）**

```
全てのRegisterに同じ in[16] が入力されるが、
load信号が1のものだけが実際に書き込む

in = 1234 (16ビット値) の場合:

Register0: load0=0 → 書き込まない（前の値を保持）
Register1: load1=0 → 書き込まない
Register2: load2=0 → 書き込まない
Register3: load3=1 → 1234を書き込む ✓
Register4～7: 書き込まない

```

**役割**: 選択されたRegisterだけが新しい値を記憶

### **Step 3: データ読み出し（Mux8Way16）**

```
読み出し時 address=011 (3) の場合

Mux8Way16が address を見て8個の出力から1つを選択:

out = Register3の出力 (out3) を選択
    = 1234

```

**役割**: 「どのRegisterから読み出すか」を選択して出力

## タイムライン例

```
時刻  address  load  in     → 動作                    out
t=0   000      1     100    → Reg0に100を書き込み     ?
t=1   000      0     999    → 読み出しのみ            100
t=2   011      1     200    → Reg3に200を書き込み     100
t=3   011      0     999    → Reg3から読み出し        200
t=4   000      0     999    → Reg0から読み出し        100

```

## 重要な3つのポイント

### 1️⃣ **全Registerに同じinが入る**

```
in[16] は全8個のRegisterに接続されている
→ でもload信号で「どれが受け取るか」を制御

```

### 2️⃣ **addressが2つの役割を持つ**

```
書き込み時: どのRegisterのloadを1にするか (DMux8Way)
読み出し時: どのRegisterのoutを選ぶか (Mux8Way16)

```

### 3️⃣ **3ビットで8個を選択**

```
address = 000 → Register0
address = 001 → Register1
...
address = 111 → Register7

2^3 = 8通り → 8個のRegisterを選択可能

```

## なぜこの構造？

- **DMux8Way**: 「書き込み先の選択」→ 1本のload信号を8本に分配
- **Register × 8**: 「データの保存」→ それぞれ独立して16ビット値を保持
- **Mux8Way16**: 「読み出し元の選択」→ 8個の出力から1つを選択

**つまり、addressという「住所」を使って、8個の「部屋」(Register)のどれに書き込む/読み出すかを制御する仕組みです！**

# RAMの階層的拡張の仕組み

## 基本原理：アドレスを分割して階層化

**アドレスビットを「上位」と「下位」に分けることで、既存のRAMチップを組み合わせて大容量化できる**

## RAM64の構造分析

### アドレスの分割

```
address[6] = 6ビット = 000000 ～ 111111

↓ 分割

address[3..5] (上位3ビット) → どのRAM8を選ぶか (8通り)
address[0..2] (下位3ビット) → RAM8内のどのRegisterを選ぶか (8通り)

8 × 8 = 64個のRegisterを選択可能

```

### 回路図

```
      address[6]
      ┌──┴──┐
   [3..5]  [0..2]
     ↓       ↓
  ┌────────────────┐
  │ DMux8Way       │ どのRAM8に書き込むか
  └┬──┬──┬───┬────┘
   │  │  │   │
load0 load1... load7
   ↓  ↓       ↓
┌─RAM8─┐   ┌─RAM8─┐
│addr  │...│addr  │← 下位3ビットで内部選択
│[0..2]│   │[0..2]│
└──┬───┘   └──┬───┘
   ↓          ↓
  out0      out7
   └────┬─────┘
   ┌────┴────────┐
   │ Mux8Way16   │ どのRAM8から読み出すか
   │ sel[3..5]   │
   └──────┬──────┘
          ↓
         out

```

## 具体例：address = 101011 (43)

```
Step 1: アドレスを分割
  101011
  ↓
  上位 [3..5] = 101 (5)
  下位 [0..2] = 011 (3)

Step 2: 書き込み (load=1の場合)
  DMux8Way(sel=101) → load5=1
  → RAM8[5]が選択される

Step 3: RAM8内部でさらに選択
  RAM8[5]内で address[0..2]=011 (3)
  → Register3が選択される

結果: RAM8[5]のRegister[3] に書き込み
     = 全体で見ると 5×8+3 = 43番目

```

## 階層的拡張パターン

### **RAM8 → RAM64**

```
Register × 8個 (3ビットアドレス)
        ↓
RAM8 × 8個 (6ビットアドレス)
= Register × 64個

address[6]:
  [3..5] → どのRAM8
  [0..2] → RAM8内のどのRegister

```

### **RAM64 → RAM512**

```
RAM8 × 8個 (6ビット)
        ↓
RAM64 × 8個 (9ビットアドレス)
= Register × 512個

address[9]:
  [6..8] → どのRAM64
  [0..5] → RAM64内のどのRegister

```

### **RAM512 → RAM4K**

```
RAM64 × 8個 (9ビット)
        ↓
RAM512 × 8個 (12ビットアドレス)
= Register × 4096個

address[12]:
  [9..11] → どのRAM512
  [0..8]  → RAM512内のどのRegister

```

### **RAM4K → RAM16K**

```
RAM512 × 8個 (12ビット)
        ↓
RAM4K × 4個 (14ビットアドレス)
= Register × 16384個

address[14]:
  [12..13] → どのRAM4K (4通り → DMux4Way使用)
  [0..11]  → RAM4K内のどのRegister

```

## 拡張の統一パターン

```
CHIP RAM_X {
    IN in[16], load, address[N];
    OUT out[16];

    PARTS:
    // 1. load信号を分配（上位ビット）
    DMux_Way(in=load, sel=address[上位], ...);

    // 2. 下位RAMチップを配置（下位ビット）
    RAM_Y(in=in, load=load0, address=address[下位], out=out0);
    RAM_Y(in=in, load=load1, address=address[下位], out=out1);
    ...

    // 3. 出力を選択（上位ビット）
    Mux_Way16(..., sel=address[上位], out=out);
}

```

## メモリ拡張の全体像

```
Register (1個, 16ビット)
    ↓ ×8
RAM8 (8個, 3ビット)
    ↓ ×8
RAM64 (64個, 6ビット)
    ↓ ×8
RAM512 (512個, 9ビット)
    ↓ ×8
RAM4K (4096個, 12ビット)
    ↓ ×4
RAM16K (16384個, 14ビット)

```

## なぜこの方法が効率的か

1. **同じパターンの繰り返し**: 既存チップを8個（または4個）並べるだけ
2. **アドレス分割の妙**: 上位ビットで「どのブロック」、下位ビットで「ブロック内のどこ」
3. **階層的思考**: 小さな部品から大きなシステムを構築（抽象化の力）

**つまり、「3ビットで8個選択」という基本原理を、何層にも積み重ねることで16Kメモリまで到達できる！** 🚀