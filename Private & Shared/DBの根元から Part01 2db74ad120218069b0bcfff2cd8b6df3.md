# DBの根元から Part01

## **プロローグ：そもそもコンピュータって何だっけ？**

<aside>
😀

データベースの話の前に、そもそもコンピュータって何なの？

</aside>

<aside>
😈

いい質問ですね！実は、コンピュータの本質って驚くほどシンプルなんです。

- **コンピュータの3つの基本機能**
    - **入力（Input）** - データを受け取る
    - **処理（Process）** - 計算したり、変換したり
    - **出力（Output）** - 結果を返す
        - そして、もう一つ超重要なのが
            - **記憶（Storage）** - データを保存しておく
</aside>

<aside>
😀

記憶？メモリのこと？

</aside>

<aside>
😈

そう！でも「記憶」には2種類あるんです

- **一時的な記憶（メモリ/RAM）**
    - 超高速
    - 電源を切ると消える
    - 高価
        - 例：作業中のExcelファイル
- **永続的な記憶（ストレージ）：**
    - 比較的遅い
    - 電源を切っても残る
    - 安価
    - 例：保存したExcelファイル

この「永続的な記憶をどう管理するか」という問題から、データベースの歴史が始まるんです。

</aside>

---

## **第1章：原始時代 - パンチカードからファイルシステムへ（1940-1960年代）**

### **1940-50年代：パンチカードの時代**

<aside>
😈

想像してみてください。1950年代のオフィス。コンピュータはまだ部屋いっぱいの巨大な機械です。

</aside>

<aside>
😀

データはどうやって保存してたの？

</aside>

<aside>
😈

パンチカード！厚紙に穴を開けて情報を記録してたんです。
https://www.nakanihon.co.jp/gijyutsu/Shimada/db/chapter010306.html

- **問題点**
    - 物理的にカードが傷むし、大量のカードを管理する必要がある
    - 検索するときは、全部のカードを見るしかない！
</aside>

### **1960年代：磁気テープとファイルシステム**

<aside>
😈

さて、時が進み、技術が進歩すると、磁気テープが登場しました。

https://www.nakanihon.co.jp/gijyutsu/Shimada/db/chapter030502.html

</aside>

<aside>
😀

昔のカセットテープみたいな？

</aside>

<aside>
😈

まさに！データを順番に記録していくんです。

- **問題点**
    - **順次アクセスしかできない**
        - データCを読むには、AとBも読む必要がある
        - 巻き戻しに時間がかかる
    - **データの重複**
        - 給与計算プログラム用の社員ファイル
        - 人事管理プログラム用の社員ファイル
            - 同じ情報が複数のファイルに存在する
</aside>

<aside>
😀

それって無駄じゃない？

</aside>

<aside>
😈

その通り！しかもこんな問題もありました。

**田中さんの住所変更シナリオ**

1. 給与ファイルの住所を更新
2. 人事ファイルの住所を更新し忘れる
3. 給与明細は新住所に届くが、人事部は旧住所を参照
4. データの不整合が発生！

この「データ重複」と「不整合」の問題が、データベースという概念を生み出していくことになりました。

</aside>

---

## **第2章：DBMSの黎明期（1960年代後半-1970年代）**

### **階層型データベース（Hierarchical Database）**

<aside>
😈

1960年代後半、IBMが画期的なシステムを開発しました。IMS（Information Management System）です。

</aside>

<aside>
😀

何が革命的だったの？

</aside>

<aside>
😈

データを「ツリー構造」で管理することです。

- **メリット**
    - 親子関係が明確
    - 高速なデータアクセス（親から子へ辿る）
- **デメリット**
    - 硬直的すぎる
    - 一つの子は一つの親しか持てない
        - 例：田中さんが営業部と技術部を兼任する場合、表現できない
- **歴史的意義**
    - NASAのアポロ計画（月面着陸）で使われました。これは本当に凄いことで、人類初の月面着陸を支えたのがIMSだったんです。
</aside>

### **ネットワーク型データベース（Network Database）**

<aside>
😈

 階層型の制限を緩和したのがネットワーク型です。

</aside>

<aside>
😀

これなら複数の部署に所属できるね！

</aside>

<aside>
😈

そうなんです。でも新たな問題が...

- **プログラマーの悲鳴**
    - // データを取得するには...
        - 1. 社員レコードを開く
        - 2. 部署へのポインタを辿る
        - 3. 部署レコードを開く
        - 4. プロジェクトへのポインタを辿る
        - 5. プロジェクトレコードを開く
        - 6. ...（延々と続く）
- **問題点**
    - プログラミングが超複雑
    - データ構造を変更すると、全アプリケーションの書き直しが必要
    - 新人が入っても理解できない
</aside>

<aside>
😀

これじゃあビジネスのスピードについていけないよね...

</aside>

<aside>
😈

まさに！ここで革命が起きます。

</aside>

---

## **第3章：革命！関係モデルの誕生（1970年）**

### **エドガー・コッド博士の論文**

<aside>
😈

1970年6月、IBMの研究者エドガー・コッド博士が一本の論文を発表しました。

タイトル：**"[A Relational Model of Data for Large Shared Data Banks](https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf)"**

</aside>

<aside>
😀

何が革命的だったの？

</aside>

<aside>
😈

彼は言ったんです：「データをテーブル（表）で表現すればいいじゃないか」と。

- **関係モデルの核心的アイデア**
    - **従来の考え方**
        - データ構造（ツリーやネットワーク）にデータを無理やり押し込める
    - **コッド博士の考え方**
        - データを自然な形（表）で表現し、関係性は別で管理する
</aside>

<aside>
😀

あ、Excel の表みたい！わかりやすい！

</aside>

<aside>
😈

そう！これが天才的なんです。人間が自然に理解できる形式でデータを表現したんです。

- **関係モデルの5つの基本概念**
    - **1. テーブル（Table / Relation）** データを行と列の表形式で格納
    - **2. 行（Row / Tuple）** 一つのデータのまとまり（例：一人の社員）
    - **3. 列（Column / Attribute）** データの属性（例：名前、年齢）
    - **4. 主キー（Primary Key）** 各行を一意に識別する値（例：社員ID）
    - **5. 外部キー（Foreign Key）** 他のテーブルとの関係を表す（例：部署ID）
</aside>

<aside>
😈

でも、これだけじゃないんです。コッド博士の本当の天才性、データ独立性の概念にあります

</aside>

<aside>
😀

データ独立性？

</aside>

<aside>
😈

これが超重要です。

- **物理的データ独立性**
    - データの物理的な保存方法（ハードディスクのどこに、どう保存するか）を変更しても、アプリケーションは影響を受けない
- **論理的データ独立性**
    - データ構造を変更しても、既存のアプリケーションへの影響を最小限にできる
</aside>

<aside>
😈

**例えば**

昔（ネットワーク型DB）は、社員テーブルに「メールアドレス」列を追加

→ 全アプリケーションの書き直しが必要

関係モデルでは、社員テーブルに「メールアドレス」列を追加

→ メールを使わない既存アプリは修正不要！

</aside>

<aside>
😀

それってめちゃくちゃ便利じゃん！

</aside>

<aside>
😈

でしょ？これによって、ビジネスの変化に柔軟に対応できるようになったんです。

</aside>

---

## **第4章：SQLの誕生と標準化（1970年代）**

### **SQL以前の世界**

<aside>
😈

コッド博士の論文は素晴らしかったけど、一つ問題がありました。

</aside>

<aside>
😀

何？

</aside>

<aside>
😈

「どうやってデータを取り出すか」の具体的な方法が決まってなかったんです。

</aside>

**昔のデータ取得（ネットワーク型DB）**

```sql
// 営業部の社員を取得
SET current_db TO company_db
FIND FIRST department WHERE name = '営業部'
WHILE found DO
FIND NEXT employee WITHIN department
PRINT employee.name
END
```

<aside>
😀

読みにくい...プログラマーしか書けない...

</aside>

### **IBMのSEQUEL → SQL**

<aside>
😈

1974年、IBMの研究所で二人の研究者（ドナルド・チェンバレンとレイモンド・ボイス）が関係モデルを実装したSystem RというDBMSを開発し、その操作言語として「SEQUEL」が生まれました。

最初の名前：**SEQUEL**（Structured English QUEry Language） → 商標の問題で**SQL**に改名しました。

**革命的だったのは**英語の文章に近い構文で書ける宣言型言語だったことです。

</aside>

```sql
SELECT 名前
FROM 社員
WHERE 部署 = '営業部';
```

<aside>
😀

読める！普通の人にも理解できる！

確かに！『営業部の社員から名前を選択して』って読めるね

</aside>

<aside>
😈

そう！これが**宣言型言語**の威力です。

</aside>

### **宣言型 vs 手続き型**

<aside>
😈

まず手続き型の言語では、「どうやって」データを取得するかを詳細に指示する必要があります

- **手続き型（Procedural）**
    - 1. 部署テーブルを開く
    - 2. '営業部'を探す
    - 3. 見つかったら社員テーブルに移動
    - 4. その部署の社員を一人ずつ取得
    - 5. 名前を出力
</aside>

<aside>
😈

一方で、宣言型の言語では「何が」欲しいかだけを指示します

- **宣言型（Declarative）**
    - SELECT 名前 FROM 社員 WHERE 部署 = '営業部';
</aside>

<aside>
😈

どうやって取得するかは、DBMSが考えてくれるんです！

</aside>

<aside>
😀

えー、賢い！

</aside>

<aside>
😈

これによって、プログラマーは「何がしたいか」に集中できるようになりました。

</aside>

### **SQLの基本構文（実例で学ぶ）**

<aside>
😈

架空の会社のデータベースで例を見ていきましょう。

</aside>

1. **データ作成**

```bash
sqlite3 sample.db
```

```sql
-- 部署テーブルを作成
CREATE TABLE 部署 (
    部署ID TEXT PRIMARY KEY,
    部署名 TEXT NOT NULL
);

-- 社員テーブルを作成
CREATE TABLE 社員 (
    社員ID TEXT PRIMARY KEY,
    名前 TEXT NOT NULL,
    年齢 INTEGER NOT NULL,
    給与 INTEGER NOT NULL,
    部署ID TEXT NOT NULL,
    FOREIGN KEY (部署ID) REFERENCES 部署(部署ID)
);

-- 部署データを挿入
INSERT INTO 部署 (部署ID, 部署名) VALUES 
('D01', '営業部'),
('D02', '技術部');

-- 社員データを挿入
INSERT INTO 社員 (社員ID, 名前, 年齢, 給与, 部署ID) VALUES 
('001', '佐藤太郎', 30, 400, 'D01'),
('002', '鈴木花子', 25, 350, 'D01'),
('003', '田中一郎', 35, 500, 'D02'),
('004', '山田美咲', 28, 420, 'D02');
```

1. **SELECT（選択）**
- 全社員の名前と年齢を取得

```sql
SELECT 名前, 年齢 FROM 社員;
```

- 結果
    
    ![スクリーンショット 2026-01-03 14.57.45.png](DB%E3%81%AE%E6%A0%B9%E5%85%83%E3%81%8B%E3%82%89%20Part01/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2026-01-03_14.57.45.png)
    
1. **WHERE（条件）**
- 30歳以上の社員

```sql
SELECT 名前, 年齢 FROM 社員 WHERE 年齢 >= 30;
```

- 結果

![スクリーンショット 2026-01-03 15.00.53.png](DB%E3%81%AE%E6%A0%B9%E5%85%83%E3%81%8B%E3%82%89%20Part01/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2026-01-03_15.00.53.png)

1. **JOIN（結合）**
- 社員と部署を結合

```sql
SELECT 社員.名前, 部署.部署名
FROM 社員
JOIN 部署 ON 社員.部署ID = 部署.部署ID;
```

- 結果

![スクリーンショット 2026-01-03 15.04.28.png](DB%E3%81%AE%E6%A0%B9%E5%85%83%E3%81%8B%E3%82%89%20Part01/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2026-01-03_15.04.28.png)

<aside>
😀

JOINって具体的にどういうこと？

</aside>

<aside>
😈

2つのテーブルを共通の列（キー）で繋げて、1つの結果として見せる操作です。
さっきの例で説明しますね。

</aside>

- 元のテーブル
    - 社員テーブル
        
        ![スクリーンショット 2026-01-03 15.10.34.png](DB%E3%81%AE%E6%A0%B9%E5%85%83%E3%81%8B%E3%82%89%20Part01/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2026-01-03_15.10.34.png)
        
    - 部署テーブル
        
        ![スクリーンショット 2026-01-03 15.10.43.png](DB%E3%81%AE%E6%A0%B9%E5%85%83%E3%81%8B%E3%82%89%20Part01/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2026-01-03_15.10.43.png)
        

<aside>
😈

JOINすると、部署IDという共通の列を使って、2つのテーブルが繋がります。

</aside>

- 結果
    
    ```sql
    SELECT 社員.名前, 部署.部署名
    FROM 社員
    JOIN 部署 ON 社員.部署ID = 部署.部署ID;
    ```
    
    ![スクリーンショット 2026-01-03 15.04.28.png](DB%E3%81%AE%E6%A0%B9%E5%85%83%E3%81%8B%E3%82%89%20Part01/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2026-01-03_15.04.28.png)
    

<aside>
😀

なるほど！部署IDが同じ行同士を繋げて、欲しい情報だけを表示してるんだね！

</aside>

<aside>
😈

その通り！これが**関係モデル**の威力です。

データを分けて保存しておいて、必要な時に組み合わせられるんです。

</aside>

### **SQLの標準化**

<aside>
😈

SQLが便利だったので、いろんな会社が真似して実装し始めました。
でも、問題が起きたんです。

</aside>

<aside>
😀

何が問題だったの？

</aside>

<aside>
😈

会社ごとに「方言」ができちゃったんです。

**1980年代の混乱**

- **Oracle**：Oracle SQL
- **IBM**：DB2 SQL
- **Microsoft**：Transact-SQL（T-SQL）
- **Sybase**：Sybase SQL
</aside>

<aside>
😀

えー、バラバラだと困るね...

</aside>

<aside>
😈

そこで、**標準化**の動きが始まりました。

</aside>

| 年 | 標準名 | 主な内容 |
| --- | --- | --- |
| 1986 | SQL-86 | 最初の標準（ANSI） |
| 1987 | SQL-87 | ISO標準として採用 |
| 1992 | SQL-92 | 大幅拡張（JOIN構文の標準化など） |
| 1999 | SQL:1999 | トリガー、再帰クエリなど追加 |
| 2003 | SQL:2003 | XML対応 |
| 2011 | SQL:2011 | 時系列データ対応 |
| 2016 | SQL:2016 | JSON対応 |
| 2023 | SQL:2023 | プロパティグラフクエリ対応 |

<aside>
😈

1986にANSI SQL標準（SQL-86）といって、アメリカ国家規格協会が標準を制定しました。

その後、何度か標準化が進みましたが、特に重要だったのが**SQL-92**です。

これによって、基本的なSQL構文が統一されました。

</aside>

<aside>
😀

基本的な統一？完全ではないの？

</aside>

<aside>
😈

そうなんです。標準はあるけど、各DBMSは独自の拡張機能も持っています。
ただ、基本部分は共通なので、SQLを学べばどのデータベースでも使えるんです。

</aside>