# DBの根本から Part04

## **第9章：Aurora - クラウドネイティブDBMSの誕生（2014年）**

### **RDSの限界**

<aside>
😈

RDSは素晴らしかったけど、ある問題がありました。

既存のDBMS（MySQL/PostgreSQL）をクラウド上で便利に使えるようにしただけで、**DBMS自体の根本的な制限は残っていた**んです。

</aside>

- **従来のDBMSの構造**
    - アプリケーションは、DBサーバーと通信します。
    - DBサーバー内には、MySQL（DBMS）というソフトウェアが動作しており、データベースの管理を行います。
    - MySQLは、同じサーバー内のローカルディスク（HDD/SSD）にデータをファイルとして保存します。
    - アプリケーション → MySQL（DBMS）→ ローカルディスクの順番でSQL文が処理され、データの読み書きが行われます。結果は逆の順番でアプリケーションに返されます。

<aside>
😈

この構造には、いくつかの問題点がありました。

</aside>

### **従来のRDBMSの3つの問題点**

**問題1：ストレージの限界**

<aside>
😈

ディスクの容量には物理的な上限がありました。

- 当時のRDS
    - 最大ストレージ：16TB
    - これ以上は物理的に増やせない
- 大規模サービスには不十分
    - YouTube、Facebook級のデータは16TBでは足りない
</aside>

**問題2：レプリケーションの複雑さ**

```
従来の構造：
    [マスター]（書き込み）
        ↓ データをコピー
    [レプリカ1]（読み取り）
        ↓ データをコピー
    [レプリカ2]（読み取り）

問題点
- マスターの負荷が高い（全レプリカにデータページ全体を送る）
- レプリケーション遅延（ラグ）が発生
- フェイルオーバーに数分かかる
- ネットワーク帯域を大量消費
```

<aside>
😀

確かに、マスター全部のコピーを送るのは大変そう...

</aside>

**問題3：I/Oボトルネック**

<aside>
😈

また、DBサーバーとストレージ間の通信が遅いという問題もあります。

</aside>

<aside>
😈

従来のMySQLでは、データを「ページ」という16KBの単位で管理しています。そのため、たった1文字だけを変更する場合でも、そのデータが含まれる16KB分のページ全体をディスクに書き込む必要があります。

</aside>

<aside>
😈

例えば、`UPDATE users SET name = '太郎' WHERE id = 1;` というSQL文で、ユーザー名を1文字変更するだけでも、MySQLは該当データが含まれる16KBのデータページ全体をディスクに書き込みます。

</aside>

<aside>
😈

この仕組みの問題点は、大量のアクセスが発生する環境では、ディスクへの書き込み処理（I/O）が追いつかず、ボトルネックになってしまうことです。小さな変更でも毎回16KBを書き込むため、無駄なディスクアクセスが増えてしまうのです。

</aside>

<aside>
😀

無駄が多いね...

</aside>

<aside>
😈

そうなんです。これらの問題を根本から解決するため、AWSは考えました。

「**クラウド専用に、ゼロからDBMSを設計し直したらどうだろう？**」

</aside>

### **Amazon Aurora の誕生：2014年11月**

<aside>
😈

**コンセプト：「クラウドのために生まれたデータベース」**

従来のDBMSは、物理サーバーで動くことを前提に設計されていました。

でも、クラウドなら別の設計が最適なはず。それがAuroraです。

</aside>

### **革命的アイデア1：ストレージとコンピュートの分離**

<aside>
😈

Auroraの最も革新的なアイデアは、「ストレージとコンピュートを完全に分離する」ことでした。

</aside>

- 従来のMySQL（RDS）

```
┌─────────────┐
│ MySQL       │ ← DBMSとストレージが一体
│   + Disk    │
└─────────────┘
```

- Aurora

```
┌─────────────┐
│ Aurora      │ ← DBMSエンジン（コンピュート層）
│ (Compute)   │    SQL処理だけを担当
└─────────────┘
       ↕ ネットワーク経由で通信
┌─────────────────────────────┐
│   Aurora Storage Layer      │ ← 独自の分散ストレージ層
│  (複数のストレージノード)     │    データ保存だけを担当
└─────────────────────────────┘

```

<aside>
😀

何が嬉しいの？

</aside>

<aside>
😈

これによって、いくつもの利点が生まれました。

</aside>

**利点1：自動スケーリング**

- 従来（RDS）
    - ディスクが足りなくなったら手動で追加
    - ダウンタイムが必要
    - 最大16TB
- Aurora
    - 10GB単位で自動拡張
    - ダウンタイムなし
    - 最大128TB（現在）

**利点2：レプリケーションの高速化**

<aside>
😈

従来のRDSでは、マスターもレプリカもそれぞれ自分専用のストレージを持っています。そのため、マスター（コンピュート）が各レプリカにデータページ全体を送信し、各レプリカが自分のストレージに書き込む必要がありました。

</aside>

<aside>
😈

Auroraでは、マスター（コンピュート層）は変更ログだけをストレージ層に送信します。ストレージ層が自動的に6コピーを作成・管理するので、マスターは1回送信するだけで済みます。レプリカ（コンピュート層）は、同じストレージ層を参照するだけなので、データのコピーが不要です。

</aside>

- **従来のRDS**：マスターもレプリカも、それぞれ**別々のストレージ**を持つ → マスターが各レプリカにデータをコピーする必要がある
- **Aurora**：全員が**同じストレージ**を見ている → データのコピーが不要！

<aside>
😀

なるほど！ストレージ側でコピーを作るから、マスターが楽なんだ！

</aside>

### **革命的アイデア2：ログベースのストレージ**

<aside>
😈

2つ目の革新は、「ログベース」のアプローチです。

</aside>

**従来のMySQL**

- データ更新時
    1. データページ全体（16KB）を読み込む
    2. 1箇所だけ変更
    3. データページ全体（16KB）を書き込む

**Aurora**

- データ更新時
    1. 変更ログ（差分）だけを書き込む

<aside>
😈

これによりI/Oが劇的に削減されるんです。

</aside>

**具体例：1000件の更新**

| 処理 | 従来のMySQL | Aurora |
| --- | --- | --- |
| 書き込みデータ量 | 16MB（16KB × 1000） | 約300KB（300B × 1000） |
| I/O回数 | 1000回 | 1000回 |
| ネットワーク転送量 | 大 | 小 |
| 処理時間 | 遅い | **速い** |

### **革命的アイデア3：クォーラムベースの耐障害性**

<aside>
😈

3つ目の革新は、「クォーラムベース」の仕組みです。

</aside>

**Auroraのデータ配置**

3つのアベイラビリティゾーン（AZ）に6つのデータコピーを配置

- AZ-1（東京-1）: [コピー1] [コピー2]
- AZ-2（東京-2）: [コピー3] [コピー4]
- AZ-3（東京-3）: [コピー5] [コピー6]

**クォーラムの仕組み**

<aside>
😈

クォーラムベースでは「過半数が成功すればOK」という考え方をします。

</aside>

書き込み：

- 6つ中4つが成功すればOK
- 2つ失敗しても大丈夫

読み取り：

- 6つ中3つが成功すればOK
- 3つ失敗しても大丈夫

<aside>
😈

従来のRDSのMulti-AZより、さらに堅牢です。

</aside>

### **Aurora はMySQLなのか？**

<aside>
😀

でも、これってもうMySQLじゃないよね？

</aside>

<aside>
😈

鋭い！その通りです。重要なポイントなので、詳しく説明しましょう。

Auroraは独自のDBMSエンジンといえます

- 内部構造は完全にオリジナル
- ストレージ層は完全に独自設計
- MySQLやPostgreSQLとは全く違う

**でも**

- SQLの文法はMySQL/PostgreSQL互換
- アプリケーションからは普通のMySQL/PostgreSQLに見える
</aside>

<aside>
😀

MySQL/PostgreSQLとの互換があるんだね。

</aside>

<aside>
😈

そうなんです。アプリケーションとAurora独自エンジンの間に互換性レイヤーというのがあり、アプリケーションからは普通のMySQLと全く同じように使えるんです

</aside>

**互換性レイヤーの仕組み**

```
┌────────────────────────┐
│  アプリケーション      │
└────────────────────────┘
        ↕
  MySQL/PostgreSQL プロトコル
        ↕
┌────────────────────────┐
│  互換性レイヤー        │ ← MySQL/PostgreSQLの振りをする
│  (Wire Protocol)       │    アプリからはMySQLに見える
└────────────────────────┘
        ↕
┌────────────────────────┐
│  Aurora独自エンジン    │ ← 実際の処理はここで行う
│  (Compute Layer)       │    全く独自の実装
└────────────────────────┘
        ↕
┌────────────────────────┐
│  Aurora Storage        │ ← 分散ストレージ層
│  (Storage Layer)       │    これも完全に独自
└────────────────────────┘

```

**アプリケーション側から見ると**

```python
# Pythonの例
import mysql.connector

# 通常のMySQLと同じコード
connection = mysql.connector.connect(
    host="aurora-cluster.xxxxx.rds.amazonaws.com",
    user="admin",
    password="password",
    database="myapp"
)

cursor = connection.cursor()
cursor.execute("SELECT * FROM users WHERE id = 1")
# ↑ 普通のMySQLと全く同じように使える！

```

<aside>
😀

なるほど！使い方は同じだけど、中身は全然違うんだね。

</aside>

### **Auroraと**RDS MySQL**トレードオフ**

<aside>
😀

じゃあ全部Auroraにすればいいじゃん！

</aside>

<aside>
😈

それが正解の場合も多いです。

でも、ケースによってはRDS MySQLの方が合理的なこともあります。

</aside>

**実際の選択基準**

- RDS MySQL（Single-AZ）を選ぶケース
    - 開発・テスト環境
    - 短時間のダウンタイムが許容できる環境
    - とにかくコストを抑えたい
    - 冗長性なしでも構わない
- RDS MySQL（Multi-AZ）を選ぶケース
    - 特殊なMySQL機能が必要
    - MyISAMエンジン
    - Aurora非対応のプラグイン
    - 将来的に他クラウドへの移行可能性がある
        - Auroraとコストはほぼ同等
        - 可用性も確保できる
- Aurora を選ぶケース
    - 本番環境（これが最も一般的）
    - 読み取り負荷が高い、またはレプリカを複数使いたい
    - パフォーマンスと可用性を重視
    - AWS に長期的にコミットできる
    - ストレージ自動拡張で運用が楽
    - レプリカ追加時のマスター負荷が低い

<aside>
😈

実際には「本番環境ならAurora」で大体OK。
コストも性能もMulti-AZ RDSと比べて優れています。

</aside>

<aside>
😈

次の章では、さらに新しい技術トレンドの世界を見ていきます。

関係モデルとは全く違うアプローチで、データベースの可能性を広げた技術です！

</aside>

---

## **第10章：現代のDB技術（2020年代）**

### **サーバーレスDB：使った分だけ課金**

<aside>
😈

これまでRDSやAuroraを見てきましたが、最近の大きなトレンドが「サーバーレス」です。

</aside>

<aside>
😀

サーバーがないってこと？

</aside>

<aside>
😈

いいえ、サーバーはあります。でも、ユーザーがサーバーを意識しなくていいんです。

</aside>

### **従来のRDSの課題**

- 従来のRDS
    - 設定が必要
        - インスタンスタイプ（t3.micro、t3.small など）
        - ストレージサイズ（20GB、100GB など）
    - 課金
        - インスタンスは常に起動
        - 使っても使わなくても24時間課金
    - 課題
        - 無駄なコスト
        - キャパシティプランニングの難しさ

### **Aurora Serverless の登場**

- 2018年：Aurora Serverless v1
- 2022年：Aurora Serverless v2（大幅改善）

<aside>
😈

Aurora Serverlessは、これらの問題を解決します。

以下のようにACUを設定すると、自動でメモリ数を調節してくれるようになります。

</aside>

- 設定すること
    - 最小キャパシティ：例：0.5 ACU
    - 最大キャパシティ：例：16 ACU
    
    ```bash
    ACU = Aurora Capacity Unit（処理能力の単位）
    1 ACU ≒ 2GBメモリ
    ```
    
- 自動で行われること
    - アクセスなし → 最小ACUまで縮小
    - アクセス少 → 0.5〜2 ACU で運用
    - アクセス増 → 自動で16 ACUまでスケール
    - アクセス減 → 自動でスケールダウン

<aside>
😀

便利！

</aside>

### **Aurora Serverless の仕組み**

```
┌────────────────────────┐
│  アプリケーション      │
└────────────────────────┘
         ↕
┌────────────────────────┐
│  プロキシ層            │ ← 接続を管理
└────────────────────────┘
         ↕
┌────────────────────────┐
│  コンピュート層        │ ← 必要に応じて増減
│  (可変ACU)             │
└────────────────────────┘
         ↕
┌────────────────────────┐
│  Aurora Storage        │ ← 常に存在
└────────────────────────┘

```

<aside>
😈

上記のように、ストレージは常に存在し、コンピュート層が必要に応じて増減します。

</aside>

### **Aurora Serverless の選択基準**

適している

- アクセスが不規則（開発環境、週末だけのサービス）
- スパイク的なアクセス

適していない

- 常時安定したアクセス
- 予算を固定したい

### **NewSQL：次世代の分散DB**

<aside>
😈

もう一つの大きなトレンドが「NewSQL」です。

</aside>

<aside>
😀

NewSQL？

</aside>

<aside>
😈

まず、従来のRDBMSの限界を理解しましょう。

</aside>

### **従来のRDBMSの限界**

- 従来のRDBMS（MySQL、PostgreSQL）
    - 読み取り：リードレプリカで分散可能
    - 書き込み：マスター1台に集中
- 問題
    - 書き込みが多いアプリではマスターがボトルネック
    - 手動シャーディングは可能だがアプリ側で実装が必要
    - グローバル分散トランザクションが困難

<aside>
😈

この限界を解決しようと、2000年代後半に**NoSQL**が登場しました。

</aside>

### **NoSQLの登場と限界**

NoSQL（MongoDB、Cassandra、DynamoDB）：

- メリット
    - 簡単に水平スケーリング
    - 柔軟なデータ構造
- デメリット
    - トランザクションが弱い
    - SQLが使えない
    - JOINができない

<aside>
😀

水平スケーリングはできるけど、トランザクションが弱いんだ。

</aside>

<aside>
😈

そうなんです。そこで考えられたのが「**NewSQL**」です。

</aside>

### **NewSQL のアイデア**

<aside>
😈

「RDBMSの厳格性 + NoSQLのスケーラビリティ」

両方のいいとこ取りです。

- NewSQL の特徴
    - 水平スケーリング可能
    - トランザクションは厳格（ACID準拠）
    - SQL使える
    - 分散しても整合性を保証
</aside>

### **代表例：Google Cloud Spanner**

**2017年：Cloud Spanner 一般公開**

<aside>
😈

Googleが開発した、世界初のグローバル分散NewSQLです。

</aside>

**グローバル分散の例**

```
┌─────────────────────────────────────┐
│        東京リージョン                │
│     [Spannerノード群]               │
└─────────────────────────────────────┘
              ↕ 同期
┌─────────────────────────────────────┐
│      ロンドンリージョン              │
│     [Spannerノード群]               │
└─────────────────────────────────────┘
              ↕ 同期
┌─────────────────────────────────────┐
│      シドニーリージョン              │
│     [Spannerノード群]               │
└─────────────────────────────────────┘

全てのリージョンで同じデータを参照
トランザクションの整合性は保証

```

<aside>
😀

世界中に分散してても、トランザクションが保証されるの？

</aside>

😈

<aside>
😈

そうなんです。TrueTime APIという独自技術で、原子時計とGPSを使って世界中のサーバーの時刻を正確に同期します。

これによってグローバル分散でもトランザクションの順序を保証できるんです。

</aside>

**SQL例**

```sql
-- 普通のSQLが使える
CREATE TABLE Users (
    UserId INT64 NOT NULL,
    Name STRING(100)
) PRIMARY KEY (UserId);

-- トランザクションも普通に使える
BEGIN TRANSACTION;
INSERT INTO Users VALUES (1, '太郎');
UPDATE Accounts SET Balance = Balance - 1000 WHERE UserId = 1;
COMMIT;

```

### **他のNewSQL**

| 製品 | 特徴 | 互換性 |
| --- | --- | --- |
| Cloud Spanner | グローバル分散、最も成熟 | 独自SQL |
| CockroachDB | オープンソース | PostgreSQL |
| TiDB | オープンソース | MySQL |

### **時系列データベース**

<aside>
😈

特定の用途に特化したDBも増えています。

「時系列データベース」です。

</aside>

<aside>
😀

時系列？

</aside>

<aside>
😈

時刻と値のペアを大量に扱うデータベースです。

</aside>

### **時系列データとは**

例

- IoTセンサー：2024-01-01 00:00:00, 温度=20.5℃
- 株価：2024-01-01 09:00:00, 価格=1500円
- サーバー監視：2024-01-01 00:00:00, CPU=45%

特徴：

- 時刻が必ず含まれる
- 追記のみ（更新・削除が少ない）
- 時間範囲での検索が多い
- データ量が膨大

### **時系列DBの必要性**

通常のMySQL/PostgreSQLの問題

- 1秒間に数千〜数万レコードの書き込みに追いつかない
- 圧縮が弱い
- 時間範囲の検索が遅い

時系列DBの最適化

- LSM-tree構造で高速な追記
- 時系列データ用の圧縮（1/10以下）
- 時間範囲検索に特化

### **代表的な時系列DB**

| 製品 | 特徴 | 用途 |
| --- | --- | --- |
| InfluxDB | 最も人気 | IoT、監視 |
| TimescaleDB | PostgreSQL拡張、SQL使える | 汎用 |
| Prometheus | 監視特化 | Kubernetes監視 |

**TimescaleDB の例**

```sql
-- 時系列テーブルに変換
SELECT create_hypertable('sensor_data', 'time');

-- 過去24時間の平均温度を1時間ごとに集計
SELECT
    time_bucket('1 hour', time) AS hour,
    AVG(temperature) AS avg_temp
FROM sensor_data
WHERE time > NOW() - INTERVAL '24 hours'
GROUP BY hour;

```

**性能比較**

| 処理 | PostgreSQL | TimescaleDB |
| --- | --- | --- |
| 100万レコード挿入 | 数分 | 数十秒 |
| 時間範囲検索 | 数秒 | 数百ミリ秒 |
| ストレージ | 約100MB | 約10〜20MB |

### **時系列DBの選択基準**

適している

- IoTセンサーデータ
- 監視データ（CPU、メモリ）
- 金融データ（株価、為替）

適していない

- トランザクション処理（更新・削除が多い）
- 複雑なJOIN

<aside>
😀

いろんな種類のDBがあるんだね！

</aside>

<aside>
😈

そうなんです。データの性質や要件に応じて、最適なDBを選ぶことが重要です。

次の章では、これまで学んだすべての技術を体系化して、全体像を理解しましょう。

</aside>